<!DOCTYPE html>
<html lang="id">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mini Game: Escape the Maze</title>
    <!-- Import Google Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <!-- Import Font Awesome for icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      /* Color and font variables */
      :root {
        --primary-color: #667eea; /* Main color */
        --secondary-color: #764ba2; /* Secondary color */
        --accent-color: #ff5722; /* Accent color */
        --background-color: #f7f7f7; /* Background color */
        --text-color: #333; /* Text color */
        --header-gradient: linear-gradient(
          135deg,
          var(--primary-color),
          var(--secondary-color)
        ); /* Header gradient */
        --shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Shadow effect */
      }

      /* Reset default margin and padding */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      /* Body styling */
      body {
        font-family: "Roboto", sans-serif;
        background-color: var(--background-color);
        color: var(--text-color);
        line-height: 1.6;
      }

      /* Header styling */
      header {
        background: var(--header-gradient);
        color: #fff;
        padding: 40px 20px;
        text-align: center;
        box-shadow: var(--shadow);
        margin-bottom: 20px;
      }
      header h1 {
        font-size: 3rem;
        margin-bottom: 15px;
        font-weight: 700;
      }
      header p {
        font-size: 1.2rem;
      }

      /* Main container styling */
      main {
        padding: 20px;
      }

      /* Game area (canvas) styling */
      #game-container {
        display: flex;
        justify-content: center;
        margin: 30px 0;
      }
      #mazeCanvas {
        background-color: #fff;
        border: none;
        box-shadow: var(--shadow);
        border-radius: 15px;
        width: 90%;
        max-width: 600px;
        height: 400px;
      }

      /* Control buttons styling */
      #controls {
        text-align: center;
        margin: 20px 0;
      }
      #controls button {
        background-color: var(--primary-color);
        color: #fff;
        border: none;
        padding: 12px 25px;
        font-size: 1rem;
        cursor: pointer;
        border-radius: 50px;
        transition: background-color 0.3s ease, transform 0.3s ease;
        box-shadow: var(--shadow);
      }
      #controls button:hover {
        background-color: var(--secondary-color);
        transform: translateY(-3px);
      }

      /* Score board styling */
      #score-board {
        text-align: center;
        margin: 20px 0;
        font-size: 1.2rem;
        background-color: #fff;
        padding: 15px;
        border-radius: 10px;
        box-shadow: var(--shadow);
      }
      #score-board p {
        margin: 5px 0;
        color: var(--accent-color);
      }

      /* Status message styling */
      #status {
        text-align: center;
        margin: 20px 0;
        background-color: #fff;
        padding: 15px;
        border-radius: 10px;
        box-shadow: var(--shadow);
      }
      #status p {
        font-size: 1.2rem;
        color: var(--accent-color);
      }

      /* Virtual arrow buttons for mobile */
      #mobile-controls {
        position: fixed; /* Fixed position on screen */
        bottom: 20px; /* Distance from bottom */
        left: 50%; /* Horizontal center */
        transform: translateX(
          -50%
        ); /* Shift left to truly center */
        z-index: 1000; /* Ensure buttons are above other elements */
        text-align: center;
      }

      .arrow-container {
        display: inline-block;
        background-color: rgba(
          255,
          255,
          255,
          0.8
        ); /* Semi-transparent background */
        padding: 10px;
        border-radius: 15px; /* Rounded corners */
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); /* Shadow effect */
      }

      .arrow-btn {
        background-color: #007bff; /* Modern blue color */
        color: white;
        border: none;
        padding: 10px 15px; /* Smaller button size */
        font-size: 1.2rem; /* Icon size */
        cursor: pointer;
        border-radius: 50%; /* Circular button */
        margin: 5px; /* Spacing between buttons */
        display: flex;
        justify-content: center;
        align-items: center;
        transition: background-color 0.3s ease, transform 0.3s ease; /* Smooth animation */
      }

      .arrow-btn:hover {
        background-color: #0056b3; /* Darker color on hover */
        transform: scale(1.1); /* Scale up effect */
      }

      .arrow-btn i {
        font-size: 1.5rem; /* Arrow icon size */
      }

      .toggle-btn {
        background-color: #dc3545; /* Red color for toggle button */
        color: white;
        border: none;
        padding: 10px 15px;
        font-size: 1rem;
        cursor: pointer;
        border-radius: 5px;
        margin-bottom: 10px;
        transition: background-color 0.3s ease;
      }

      .toggle-btn:hover {
        background-color: #c82333; /* Darker color on hover */
      }

      .horizontal-arrows {
        display: flex;
        justify-content: center; /* Align left-right buttons */
      }

      /* Hide buttons on desktop */
      @media (min-width: 769px) {
        #mobile-controls {
          display: none !important;
        }
      }

      /* Footer styling */
      footer {
        background-color: #333;
        color: #fff;
        text-align: center;
        padding: 20px 0;
        margin-top: 40px;
        font-size: 0.9rem;
      }

      /* Responsive design */
      @media (max-width: 768px) {
        header h1 {
          font-size: 2.2rem;
        }
        header p {
          font-size: 1rem;
        }
        #mazeCanvas {
          height: 300px;
        }
        #score-board,
        #status {
          font-size: 1rem;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Escape the Maze</h1>
      <p>
        Use arrow keys (or W, A, S, D) to move the player and find the exit!
      </p>
    </header>
    <main>
      <section id="game-container">
        <canvas id="mazeCanvas"></canvas>
      </section>
      <section id="controls">
        <button id="restartBtn">Restart Game</button>
      </section>
      <!-- Score Board: Display timer and score -->
      <section id="score-board">
        <p id="timer">Time: 0.0s</p>
        <p id="score"></p>
      </section>
      <section id="status">
        <p id="message">Enjoy the game! Find the exit...</p>
      </section>
      <!-- Virtual arrow buttons for mobile -->
      <section id="mobile-controls" style="display: none">
        <div class="arrow-container">
          <button id="toggleBtn" class="toggle-btn">Hide Controls</button>
          <button id="upBtn" class="arrow-btn">
            <i class="fas fa-arrow-up"></i>
          </button>
          <div class="horizontal-arrows">
            <button id="leftBtn" class="arrow-btn">
              <i class="fas fa-arrow-left"></i>
            </button>
            <button id="rightBtn" class="arrow-btn">
              <i class="fas fa-arrow-right"></i>
            </button>
          </div>
          <button id="downBtn" class="arrow-btn">
            <i class="fas fa-arrow-down"></i>
          </button>
        </div>
      </section>
    </main>
    <footer>
      <p>Â© 2025 Escape the Maze. All rights reserved.</p>
    </footer>
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize canvas and drawing context
        const canvas = document.getElementById("mazeCanvas");
        const ctx = canvas.getContext("2d");
        let canvasWidth = (canvas.width = canvas.offsetWidth);
        let canvasHeight = (canvas.height = canvas.offsetHeight);

        // Maze configuration: set number of columns and rows
        const cols = 15;
        const rows = 10;
        const cellSize = Math.min(canvasWidth / cols, canvasHeight / rows);
        let grid = [];
        let stack = [];

        // Variables for player and exit point
        let player = {};
        let exit = {};

        // Variables for timer and score
        let startTime = 0;
        let timerInterval = null;
        let timerStarted = false;

        // Variables for mobile button status
        let controlsVisible = true;

        // Function to set random start and finish positions
        function setRandomStartAndFinish() {
          let playerRow = Math.floor(Math.random() * rows);
          let playerCol = Math.floor(Math.random() * cols);
          let exitRow, exitCol;
          const minDistance = 7; // Minimum Manhattan distance between start and finish
          do {
            exitRow = Math.floor(Math.random() * rows);
            exitCol = Math.floor(Math.random() * cols);
          } while (Math.abs(exitRow - playerRow) + Math.abs(exitCol - playerCol) < minDistance);
          player = {
            row: playerRow,
            col: playerCol,
            color: "#FF5722",
          };
          exit = {
            row: exitRow,
            col: exitCol,
          };
        }

        // Constructor for maze cell object
        function Cell(row, col) {
          this.row = row;
          this.col = col;
          this.walls = [true, true, true, true]; // [top, right, bottom, left]
          this.visited = false;
        }

        // Create maze grid
        function createGrid() {
          grid = [];
          for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
              grid.push(new Cell(r, c));
            }
          }
        }

        // Get cell index in grid array
        function index(row, col) {
          if (row < 0 || col < 0 || row >= rows || col >= cols) return -1;
          return row * cols + col;
        }

        // Maze generation using recursive backtracking algorithm
        function generateMaze() {
          let startIndex = Math.floor(Math.random() * grid.length);
          let current = grid[startIndex];
          current.visited = true;
          stack.push(current);

          while (stack.length > 0) {
            current = stack[stack.length - 1];
            let next = checkNeighbors(current);
            if (next) {
              next.visited = true;
              stack.push(next);
              removeWalls(current, next);
            } else {
              stack.pop();
            }
          }
        }

        // Check unvisited neighbors of a cell
        function checkNeighbors(cell) {
          let neighbors = [];
          let top = grid[index(cell.row - 1, cell.col)];
          let right = grid[index(cell.row, cell.col + 1)];
          let bottom = grid[index(cell.row + 1, cell.col)];
          let left = grid[index(cell.row, cell.col - 1)];

          if (top && !top.visited) neighbors.push(top);
          if (right && !right.visited) neighbors.push(right);
          if (bottom && !bottom.visited) neighbors.push(bottom); // Small bug here, should be 'bottom'
          if (left && !left.visited) neighbors.push(left);

          return neighbors.length > 0
            ? neighbors[Math.floor(Math.random() * neighbors.length)]
            : undefined;
        }

        // Remove walls between two adjacent cells
        function removeWalls(current, next) {
          let x = current.col - next.col;
          let y = current.row - next.row;
          if (x === 1) {
            current.walls[3] = false;
            next.walls[1] = false;
          } else if (x === -1) {
            current.walls[1] = false;
            next.walls[3] = false;
          }
          if (y === 1) {
            current.walls[0] = false;
            next.walls[2] = false;
          } else if (y === -1) {
            current.walls[2] = false;
            next.walls[0] = false;
          }
        }

        // Draw the maze on the canvas
        function drawMaze() {
          ctx.clearRect(0, 0, canvasWidth, canvasHeight);
          grid.forEach((cell) => {
            let x = cell.col * cellSize;
            let y = cell.row * cellSize;
            ctx.strokeStyle = "#444";
            ctx.lineWidth = 2;
            if (cell.walls[0]) {
              ctx.beginPath();
              ctx.moveTo(x, y);
              ctx.lineTo(x + cellSize, y);
              ctx.stroke();
            }
            if (cell.walls[1]) {
              ctx.beginPath();
              ctx.moveTo(x + cellSize, y);
              ctx.lineTo(x + cellSize, y + cellSize);
              ctx.stroke();
            }
            if (cell.walls[2]) {
              ctx.beginPath();
              ctx.moveTo(x + cellSize, y + cellSize);
              ctx.lineTo(x, y + cellSize);
              ctx.stroke();
            }
            if (cell.walls[3]) {
              ctx.beginPath();
              ctx.moveTo(x, y + cellSize);
              ctx.lineTo(x, y);
              ctx.stroke();
            }
          });
        }

        // Draw the finish marker
        function drawFinish() {
          let finishX = exit.col * cellSize + cellSize / 2;
          let finishY = exit.row * cellSize + cellSize / 2;
          let radius = cellSize / 4;
          ctx.beginPath();
          ctx.arc(finishX, finishY, radius, 0, Math.PI * 2, false);
          ctx.fillStyle = "#28a745";
          ctx.fill();
          ctx.lineWidth = 3;
          ctx.strokeStyle = "#fff";
          ctx.stroke();
        }

        // Draw the player
        function drawPlayer() {
          let x = player.col * cellSize + cellSize / 4;
          let y = player.row * cellSize + cellSize / 4;
          let size = cellSize / 2;
          ctx.fillStyle = player.color;
          ctx.fillRect(x, y, size, size);
        }

        // Update game display
        function updateGame() {
          drawMaze();
          drawFinish();
          drawPlayer();
          checkWin();
        }

        // Update timer
        function updateTimer() {
          const elapsed = (Date.now() - startTime) / 1000;
          document.getElementById(
            "timer"
          ).textContent = `Time: ${elapsed.toFixed(1)}s`;
        }

        // Detect mobile device
        function isMobileDevice() {
          return /Mobi|Android/i.test(navigator.userAgent);
        }

        // Show virtual arrow buttons on mobile
        function showMobileControls() {
          if (isMobileDevice()) {
            document.getElementById("mobile-controls").style.display = "block";
          }
        }

        // Move player based on direction
        function movePlayer(direction) {
          let prevRow = player.row;
          let prevCol = player.col;
          let currentCell = grid[index(player.row, player.col)];
          if (direction === "up" && !currentCell.walls[0]) {
            player.row--;
          } else if (direction === "right" && !currentCell.walls[1]) {
            player.col++;
          } else if (direction === "down" && !currentCell.walls[2]) {
            player.row++;
          } else if (direction === "left" && !currentCell.walls[3]) {
            player.col--;
          }
          if (
            (player.row !== prevRow || player.col !== prevCol) &&
            !timerStarted
          ) {
            timerStarted = true;
            startTime = Date.now();
            timerInterval = setInterval(updateTimer, 100);
          }
          updateGame();
        }

        // Handle keyboard input
        function handleKeyDown(e) {
          let direction;
          if (e.key === "ArrowUp" || e.key === "w") direction = "up";
          else if (e.key === "ArrowRight" || e.key === "d") direction = "right";
          else if (e.key === "ArrowDown" || e.key === "s") direction = "down";
          else if (e.key === "ArrowLeft" || e.key === "a") direction = "left";
          if (direction) movePlayer(direction);
        }

        // Check if player wins and disable movement
        function checkWin() {
          if (player.row === exit.row && player.col === exit.col) {
            clearInterval(timerInterval);
            const elapsed = (Date.now() - startTime) / 1000;
            document.getElementById("message").textContent =
              "Congratulations! You escaped the maze!";
            document.getElementById(
              "score"
            ).textContent = `Your Time: ${elapsed.toFixed(1)}s`;

            // Stop keyboard input
            document.removeEventListener("keydown", handleKeyDown);

            // Disable mobile buttons
            if (isMobileDevice()) {
              document.getElementById("upBtn").disabled = true;
              document.getElementById("rightBtn").disabled = true;
              document.getElementById("downBtn").disabled = true;
              document.getElementById("leftBtn").disabled = true;
            }
          }
        }

        // Restart the game
        function restartGame() {
          clearInterval(timerInterval);
          timerStarted = false;
          createGrid();
          generateMaze();
          setRandomStartAndFinish();
          updateGame();
          document.getElementById("message").textContent =
            "Enjoy the game! Find the exit...";
          document.getElementById("score").textContent = "";
          document.getElementById("timer").textContent = "Time: 0.0s";
          document.addEventListener("keydown", handleKeyDown);

          // Re-enable mobile buttons
          if (isMobileDevice()) {
            document.getElementById("upBtn").disabled = false;
            document.getElementById("rightBtn").disabled = false;
            document.getElementById("downBtn").disabled = false;
            document.getElementById("leftBtn").disabled = false;
          }
        }

        // Setup mobile controls
        function setupMobileControls() {
          if (isMobileDevice()) {
            document
              .getElementById("upBtn")
              .addEventListener("click", () => movePlayer("up"));
            document
              .getElementById("rightBtn")
              .addEventListener("click", () => movePlayer("right"));
            document
              .getElementById("downBtn")
              .addEventListener("click", () => movePlayer("down"));
            document
              .getElementById("leftBtn")
              .addEventListener("click", () => movePlayer("left"));

            // Setup toggle button
            document
              .getElementById("toggleBtn")
              .addEventListener("click", function () {
                const arrowBtns = document.querySelectorAll(".arrow-btn");
                if (controlsVisible) {
                  arrowBtns.forEach((btn) => (btn.style.display = "none"));
                  this.textContent = "Show Controls";
                } else {
                  arrowBtns.forEach(
                    (btn) => (btn.style.display = "inline-block")
                  );
                  this.textContent = "Hide Controls";
                }
                controlsVisible = !controlsVisible;
              });
          }
        }

        // Initialize the game
        function init() {
          createGrid();
          generateMaze();
          setRandomStartAndFinish();
          updateGame();
          document.addEventListener("keydown", handleKeyDown);
          document
            .getElementById("restartBtn")
            .addEventListener("click", restartGame);
          showMobileControls();
          setupMobileControls();
        }

        // Adjust canvas size on window resize
        window.addEventListener("resize", function () {
          canvasWidth = canvas.width = canvas.offsetWidth;
          canvasHeight = canvas.height = canvas.offsetHeight;
          updateGame();
        });

        // Start the game
        init();
      });
    </script>
  </body>
</html>
